#include <iostream>
struct Node				//Структура, являющаяся звеном списка
{
	int value;			// Значение x будет передаваться в список                
	Node* next;			//Указатели на адреса следующего и предыдущего элементов списка
	Node* prev;
};
class List
{
	int count;
	Node* head;				//Указатели на адреса начала списка и его конца
	Node* tail;
public:
	List()
	{
		this->count = 0;
		this->head = NULL;			// Инициализируем адреса как пустые
		this->tail = NULL;
	}
	void Add(int value)
	{
		Node* tmp = new Node;				//Выделение памяти под новый элемент структуры
		tmp->next = NULL;					//Указываем, что изначально по следующему адресу пусто
		tmp->value = value;					//Записываем значение в структуру
		count++;
		if (head != NULL)                   //Если список не пуст
		{
			tmp->prev = tail;               //Указываем адрес на предыдущий элемент в соотв. поле
			tail->next = tmp;               //Указываем адрес следующего за хвостом элемента
			tail = tmp;                     //Меняем адрес хвоста
		}
		else								//Если список пустой
		{
			tmp->prev = NULL;               //Предыдущий элемент указывает в пустоту
			head = tail = tmp;              //Голова=Хвост=тот элемент, что сейчас добавили
		}
	}
	void Show()
	{
		Node* tmp = tail;                   //Временный указатель на адрес последнего элемента
		tmp = head;                       //Временно указываем на адрес первого элемента
		while (tmp != NULL)              //Пока не встретим пустое значение
		{
			std::cout << tmp->value << " ";        //Выводим каждое считанное значение на экран
			tmp = tmp->next;             //Смена адреса на адрес следующего элемента
		}
		std::cout << "\n";
	}
	bool isInList(int value)
	{
		bool isIn = false;
		Node* tmp = head;
		while (tmp != NULL)
		{
			if (tmp->value == value)
			{
				isIn = true;
				break;
			}
			tmp = tmp->next;
		}
		return isIn;
	}
	void removeFromList(int value)
	{
		if (value == 1 && head->next)						//Если удаляем первый, но есть и другие, то
		{
			Node* tmp = head;								//Указываем, что нам нужно начало списка
			head = head->next;	                            //Сдвигаем начало на следующий за началом элемент
			head->prev = NULL;	                            //Делаем так, чтоб предыдущий началу элемент был пустым
			delete tmp;										//Удаляем удаляемое начало
			count--;
		}
		else if ((value == 1) and (head == tail)) {            //Если удаляем первый, но в списке только 1 элемент

			head->next = NULL;	                            //обнуляем все что нужно
			head = NULL;
			delete head;		                            //Удаляем указатель на начало
			count = 0;		                                //Обязательно обозначаем, что в списке ноль элементов
			return;			                                //и выходим из функции
		}
		//Также может быть, что удаляемый элемент является последним элементом списка
		if (value == count) {
			Node* tmp = tail;	                            //Указываем, что нам нужен хвост
			tail = tail->prev;	                                //Отодвигаем хвост немного назад
			tail->next = NULL;	                                //Обозначаем, что впереди за хвостом пусто
			delete tmp;	                                    //Очищаем память от бывшего хвоста
			count--;		                                    //Обязательно уменьшаем счетчик элементов
			return;		                                    //И выходим из функции
		}

		//Если же удаляемый элемент лежит где-то в середине списка, то тогда его можно удалить

		Node* tmp = head, * tmp2;                        //temp-Удаляемый элемент, temp2 нужен, чтобы не потерять данные

			//cout<<count_<<"\n";
		for (int i = 0; i < value - 1; i++) tmp = tmp->next;  //Идем к адресу удаляемого элемента

		tmp2 = tmp;	                                //Временно запоминаем адрес удаляемого элемента
		tmp2->prev->next = tmp->next;	            //Записываем данные, что следующий за перед сейчас удаляемым элементом - это следующий от удаляемого
		tmp2->next->prev = tmp->prev;               //а предыдущий для следующего - это предыдущий для удаляемого
		delete tmp;                               //теперь смело можно освободить память, удалив адрес на начало удаляемого элемента
		count--;                                         //Обязательно уменьшаем число элементов в списке.
		
														  
		/*Node* tmp = head;
		while (tmp != NULL)
		{
			if (isInList(value) == true)
			{
				tmp = tmp->next;
				break;
			}
			tmp = tmp->next;
		}*/
	}
};
int main()
{
	List lst; //Объявляем переменную, тип которой есть список
	lst.Add(100); //Добавляем в список элементы
	lst.Add(200);
	lst.Add(900);
	lst.Add(888);
	lst.Show(); //Отображаем список на экране
	std::cout<<lst.isInList(900);
	std::cout << "\n";
	lst.removeFromList(2);
	lst.Show();
}
